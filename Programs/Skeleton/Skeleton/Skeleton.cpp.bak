//=============================================================================================
// Mintaprogram: Z�ld h�romsz�g. Ervenyes 2019. osztol.
//
// A beadott program csak ebben a fajlban lehet, a fajl 1 byte-os ASCII karaktereket tartalmazhat, BOM kihuzando.
// Tilos:
// - mast "beincludolni", illetve mas konyvtarat hasznalni
// - faljmuveleteket vegezni a printf-et kiveve
// - Mashonnan atvett programresszleteket forrasmegjeloles nelkul felhasznalni es
// - felesleges programsorokat a beadott programban hagyni!!!!!!! 
// - felesleges kommenteket a beadott programba irni a forrasmegjelolest kommentjeit kiveve
// ---------------------------------------------------------------------------------------------
// A feladatot ANSI C++ nyelvu forditoprogrammal ellenorizzuk, a Visual Studio-hoz kepesti elteresekrol
// es a leggyakoribb hibakrol (pl. ideiglenes objektumot nem lehet referencia tipusnak ertekul adni)
// a hazibeado portal ad egy osszefoglalot.
// ---------------------------------------------------------------------------------------------
// A feladatmegoldasokban csak olyan OpenGL fuggvenyek hasznalhatok, amelyek az oran a feladatkiadasig elhangzottak 
// A keretben nem szereplo GLUT fuggvenyek tiltottak.
//
// NYILATKOZAT
// ---------------------------------------------------------------------------------------------
// Nev    : Demeter Zal�n
// Neptun : VERF1U
// ---------------------------------------------------------------------------------------------
// ezennel kijelentem, hogy a feladatot magam keszitettem, es ha barmilyen segitseget igenybe vettem vagy
// mas szellemi termeket felhasznaltam, akkor a forrast es az atvett reszt kommentekben egyertelmuen jeloltem.
// A forrasmegjeloles kotelme vonatkozik az eloadas foliakat es a targy oktatoi, illetve a
// grafhazi doktor tanacsait kiveve barmilyen csatornan (szoban, irasban, Interneten, stb.) erkezo minden egyeb
// informaciora (keplet, program, algoritmus, stb.). Kijelentem, hogy a forrasmegjelolessel atvett reszeket is ertem,
// azok helyessegere matematikai bizonyitast tudok adni. Tisztaban vagyok azzal, hogy az atvett reszek nem szamitanak
// a sajat kontribucioba, igy a feladat elfogadasarol a tobbi resz mennyisege es minosege alapjan szuletik dontes.
// Tudomasul veszem, hogy a forrasmegjeloles kotelmenek megsertese eseten a hazifeladatra adhato pontokat
// negativ elojellel szamoljak el es ezzel parhuzamosan eljaras is indul velem szemben.
//=============================================================================================
#include "framework.h"

// 2D camera
class Camera2D {
	vec2 wCenter; // center in world coordinates
	vec2 wSize;   // width and height in world coordinates
public:
	Camera2D() : wCenter(0, 0), wSize(200, 200) { }

	mat4 V() { return TranslateMatrix(-wCenter); }
	mat4 P() { return ScaleMatrix(vec2(2 / wSize.x, 2 / wSize.y)); }

	mat4 Vinv() { return TranslateMatrix(wCenter); }
	mat4 Pinv() { return ScaleMatrix(vec2(wSize.x / 2, wSize.y / 2)); }

	void Zoom(float s) { wSize = wSize * s; }
	void Pan(vec2 t) { wCenter = wCenter + t; }
};

Camera2D camera;		// 2D camera
GPUProgram gpuProgram;	// vertex and fragment shaders

class Graph {
	unsigned int vao[2];	// vertex array object id
	float sx, sy;		// scaling
	vec2 wTranslate;	// translation
	float phi;			// angle of rotation
public:
	std::vector<vec4> vertices;
	std::vector<vec2> connections;

	Graph() { 
		for (int i = 0; i < NUM_OF_VERTICES; ++i) {
			float MAX = 1, MIN = -MAX;
			float x = MIN + (float)(rand()) / ((float)(RAND_MAX / (MAX - MIN)));
			float y = MIN + (float)(rand()) / ((float)(RAND_MAX / (MAX - MIN)));
			vertices.push_back(vec4(x, y, 0, sqrt(x * x + y * y + 1)));
		}

		int i = 0;
		int idx = 0;
		while (i < NUM_OF_CONNECTIONS) {
			int idx1 = rand() % NUM_OF_VERTICES, idx2 = rand() % NUM_OF_VERTICES;
			if (idx1 == idx2) continue;
			bool inConnections = false;
			for (std::vector<vec2>::iterator it = connections.begin(); it != connections.end(); ++it) {
				if ((it->x == idx1 && it->y == idx2) || (it->x == idx2 && it->y == idx1)) {
					inConnections = true;
					break;
				}
			}
			if (inConnections) continue;
			connections.push_back(vec2(idx1, idx2));
			++i;
		}

		Animate(0); }

	void create() {
		glGenVertexArrays(2, &vao[0]);	// create 1 vertex array object
		unsigned int vbo[2];		// vertex buffer objects
		glGenBuffers(2, &vbo[0]);	// Generate 2 vertex buffer objects

		glBindVertexArray(vao[0]);		// make it active
		// vertex coordinates: vbo[0] -> Attrib Array 0 -> vertexPosition of the vertex shader
		glBindBuffer(GL_ARRAY_BUFFER, vbo[0]); // make it active, it is an array
		int idxV = 0;
		float arrayV[NUM_OF_VERTICES * 2];
		for (std::vector<vec4>::iterator it = vertices.begin(); it != vertices.end(); ++it) {
			arrayV[idxV++] = it->x / it->w;
			arrayV[idxV++] = it->y / it->w;
		}		
		glBufferData(GL_ARRAY_BUFFER, sizeof(arrayV), arrayV, GL_DYNAMIC_DRAW);	// copy to the GPU
		// Map Attribute Array 0 to the current bound vertex buffer (vbo[0])
		glEnableVertexAttribArray(0);
		// Data organization of Attribute Array 0 
		glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, NULL); // Attribute Array 0, components/attribute, component type, normalize?, tightly packed




		glBindVertexArray(vao[1]);		// make it active
		// vertex coordinates: vbo[0] -> Attrib Array 0 -> vertexPosition of the vertex shader
		glBindBuffer(GL_ARRAY_BUFFER, vbo[1]); // make it active, it is an array
		int idxC = 0;
		float arrayC[NUM_OF_CONNECTIONS * 4];
		for (std::vector<vec2>::iterator it = connections.begin(); it != connections.end(); ++it) {
			arrayC[idxC++] = vertices[(const int)it->x].x / vertices[(const int)it->x].w;
			arrayC[idxC++] = vertices[(const int)it->x].y / vertices[(const int)it->x].w;
			arrayC[idxC++] = vertices[(const int)it->y].x / vertices[(const int)it->y].w;
			arrayC[idxC++] = vertices[(const int)it->y].y / vertices[(const int)it->y].w;
		}
		glBufferData(GL_ARRAY_BUFFER, sizeof(arrayC), arrayC, GL_DYNAMIC_DRAW);	// copy to the GPU
		// Map Attribute Array 1 to the current bound vertex buffer (vbo[1])
		glEnableVertexAttribArray(1);  // Vertex position
		// Data organization of Attribute Array 1
		glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, NULL); // Attribute Array 1, components/attribute, component type, normalize?, tightly packed
	}

	void Animate(float t) {
		sx = 10;
		sy = 10;
		wTranslate = vec2(0, 0);
		phi = t;
	}

	mat4 M() {
		mat4 Mscale(sx, 0, 0, 0,
			0, sy, 0, 0,
			0, 0, 0, 0,
			0, 0, 0, 1); // scaling

		mat4 Mrotate(cosf(phi), sinf(phi), 0, 0,
			-sinf(phi), cosf(phi), 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1); // rotation

		mat4 Mtranslate(1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 0, 0,
			wTranslate.x, wTranslate.y, 0, 1); // translation

		return Mscale * Mrotate * Mtranslate;	// model transformation
	}

	void Draw() {
		// set GPU uniform matrix variable MVP with the content of CPU variable MVPTransform
		mat4 MVPTransform = M() * camera.V() * camera.P();
		gpuProgram.setUniform(MVPTransform, "MVP");

		int location = glGetUniformLocation(gpuProgram.getId(), "color");
		
		glBindVertexArray(vao[0]);	// make the vao and its vbos active playing the role of the data source
		// Set color to (1, 0, 0) = red
		glUniform3f(location, 1.0f, 0.0f, 0.0f); // 3 floats
		glDrawArrays(GL_POINTS, 0 /*startIdx*/, NUM_OF_VERTICES /*# Elements*/);

		glBindVertexArray(vao[1]);	// make the vao and its vbos active playing the role of the data source
		// Set color to (1, 1, 0) = yellow
		glUniform3f(location, 1.0f, 1.0f, 0.0f); // 3 floats
		glDrawArrays(GL_LINES, 0 /*startIdx*/, NUM_OF_CONNECTIONS * 4 /*# Elements*/);
	}
};

const int NUM_OF_VERTICES = 50;
const int NUM_OF_CONNECTIONS = 61;
//vec4 vertices[NUM_OF_VERTICES];
//vec2 connections[NUM_OF_CONNECTIONS];
//float array[2 * NUM_OF_VERTICES + NUM_OF_CONNECTIONS * 4];

bool operator==(const vec2& v1, const vec2& v2) {
	return (v1.x == v2.x && v1.y == v2.y);
}

float distance(vec4 a, vec4 b) {
	return sqrt(pow((a.x - b.x), 2) + pow((a.y - b.y), 2));
}

bool isConnected(const vec4 a, const vec4 b) {
	bool connected = false;
	for (int l = 0; l < NUM_OF_CONNECTIONS; ++l) {
		const int idx1 = (const int)connections[l].x;
		const int idx2 = (const int)connections[l].y;
		vec2 tmpA(a.x, a.y);
		vec2 tmpB(b.x, b.y);
		vec2 tmp1(vertices[idx1].x, vertices[idx1].y);
		vec2 tmp2(vertices[idx2].x, vertices[idx2].y);
		if ((tmp1 == tmpA && tmp2 == tmpB) || (tmp1 == tmpB && tmp2 == tmpA)) {
			connected = true;
			break;
		}
	}
	return connected;
}

int numOfConnections(vec4 a) {
	int c = 0;
	for (int i = 0; i < NUM_OF_CONNECTIONS;  ++i) {
		if (vertices[(const int)connections[i].x].x == a.x || vertices[(const int)connections[i].y].x == a.x)
			c++;
	}
	return c;
}

void bubbleSortIdx(int sorted[]) {
	for (int i = 0; i < NUM_OF_VERTICES; ++i) {
		sorted[i] = i;
	}

	for (int i = 0; i < NUM_OF_VERTICES - 1; i++)
		for (int j = 0; j < NUM_OF_VERTICES - i - 1; j++)
			if (numOfConnections(vertices[sorted[j]]) > numOfConnections(vertices[sorted[j + 1]])) {
				int t = sorted[j];
				sorted[j] = sorted[j + 1];
				sorted[j + 1] = t;
			}
}

// vertex shader in GLSL: It is a Raw string (C++11) since it contains new line characters
const char * const vertexSource = R"(
	#version 330				// Shader 3.3
	precision highp float;		// normal floats, makes no difference on desktop computers

	uniform mat4 MVP;			// uniform variable, the Model-View-Projection transformation matrix
	//layout(location = 0) in vec2 vp;	// Varying input: vp = vertex position is expected in attrib array 0
	
	void main() {
		gl_Position = vec4(vp.x, vp.y, 0, 1) * MVP;		// transform vp from modeling space to normalized device space
	}
)";

// fragment shader in GLSL
const char * const fragmentSource = R"(
	#version 330			// Shader 3.3
	precision highp float;	// normal floats, makes no difference on desktop computers
	
	uniform vec3 color;		// uniform variable, the color of the primitive
	out vec4 outColor;		// computed color of the current pixel

	void main() {
		outColor = vec4(color, 1);	// computed color is the color of the primitive
	}
)";

unsigned int vao;	   // virtual world on the GPU

// Initialization, create an OpenGL context
void onInitialization() {
	glViewport(0, 0, windowWidth, windowHeight);
	glPointSize(8);
	glLineWidth(1);

	glGenVertexArrays(1, &vao);	// get 1 vao id
	glBindVertexArray(vao);		// make it active

	unsigned int vbo;		// vertex buffer object
	glGenBuffers(1, &vbo);	// Generate 1 buffer
	glBindBuffer(GL_ARRAY_BUFFER, vbo);
	// Geometry with 24 bytes (6 floats or 3 x 2 coordinates)
	
	
	for (int i = 0; i < NUM_OF_VERTICES; ++i) {
		float MAX = 1, MIN = -MAX;
		float x = MIN + (float) (rand()) / ((float) (RAND_MAX / (MAX - MIN)));
		float y = MIN + (float) (rand()) / ((float) (RAND_MAX / (MAX - MIN)));
		vertices[i] = vec4(x, y, 0, sqrt(x * x + y * y + 1));
	}  

	
	int i = 0;
	int idx = 0;
	while (i < NUM_OF_CONNECTIONS) {
		int idx1 = rand() % NUM_OF_VERTICES, idx2 = rand() % NUM_OF_VERTICES;
		if (idx1 == idx2) continue;
		bool inConnections = false;
		for (int j = 0; j < NUM_OF_CONNECTIONS; ++j) {
			if ((connections[j].x == idx1 && connections[j].y == idx2) || (connections[j].x == idx2 && connections[j].y == idx1)) {
				inConnections = true;
				break;
			}
		}
		if (inConnections) continue;
		connections[idx++] = vec2(idx1, idx2);
		++i;
	}

	idx = 0;
	for (int i = 0; i < NUM_OF_VERTICES; ++i) {
		array[idx++] = vertices[i].x / vertices[i].w;
		array[idx++] = vertices[i].y / vertices[i].w;
	}
	for (int i = 0; i < NUM_OF_CONNECTIONS; ++i) {
		array[idx++] = vertices[(const int)connections[i].x].x / vertices[(const int)connections[i].x].w;
		array[idx++] = vertices[(const int)connections[i].x].y / vertices[(const int)connections[i].x].w;
		array[idx++] = vertices[(const int)connections[i].y].x / vertices[(const int)connections[i].y].w;
		array[idx++] = vertices[(const int)connections[i].y].y / vertices[(const int)connections[i].y].w;
	}

	glBufferData(GL_ARRAY_BUFFER, 	// Copy to GPU target
		sizeof(array),  // # bytes
		array,	      	// address
		GL_STATIC_DRAW);	// we do not change later

	glEnableVertexAttribArray(0);  // AttribArray 0
	glVertexAttribPointer(0,       // vbo -> AttribArray 0
		2, GL_FLOAT, GL_FALSE, // two floats/attrib, not fixed-point
		0, NULL); 		     // stride, offset: tightly packed

	// create program for the GPU
	gpuProgram.create(vertexSource, fragmentSource, "outColor");
}

// Window has become invalid: Redraw
void onDisplay() {
	
	glClearColor(0, 0, 0, 0);     // background color
	glClear(GL_COLOR_BUFFER_BIT); // clear frame buffer

	float MVPtransf[4][4] = { 1, 0, 0, 0,    // MVP matrix, 
							  0, 1, 0, 0,    // row-major!
							  0, 0, 1, 0,
							  0, 0, 0, 1 };

	int location = glGetUniformLocation(gpuProgram.getId(), "MVP");	// Get the GPU location of uniform variable MVP
	glUniformMatrix4fv(location, 1, GL_TRUE, &MVPtransf[0][0]);	// Load a 4x4 row-major float matrix to the specified location

	location = glGetUniformLocation(gpuProgram.getId(), "color");
	glBindVertexArray(vao);  // Draw call

	// Set color to (1, 0, 0) = red
	glUniform3f(location, 1.0f, 0.0f, 0.0f); // 3 floats
	glDrawArrays(GL_POINTS, 0 /*startIdx*/, NUM_OF_VERTICES /*# Elements*/);

	// Set color to (1, 1, 0) = yellow
	glUniform3f(location, 1.0f, 1.0f, 0.0f); // 3 floats
	glDrawArrays(GL_LINES, NUM_OF_VERTICES /*startIdx*/, NUM_OF_CONNECTIONS * 4 /*# Elements*/);

	glutSwapBuffers(); // exchange buffers for double buffering

}

// Key of ASCII code pressed
void onKeyboard(unsigned char key, int pX, int pY) {
	if (key == 'd') glutPostRedisplay();         // if d, invalidate display, i.e. redraw
	if (key == ' ') {
		int sorted[NUM_OF_VERTICES]; bubbleSortIdx(sorted);
		for (int z = 0; z < 1; ++z) {
			for (int i = 0; i < 50; ++i) {
				vec4 m(0, 0, 0, 0);
				int M = 0;
				for (int j = 0; j < NUM_OF_VERTICES; ++j) {
					if (i == j) continue;
					if (numOfConnections(vertices[sorted[i]]) < 0) continue;
					if (isConnected(vertices[sorted[i]], vertices[j])) {
						m = (+1) * vertices[j];
						M += 1;
					}
					else {
						m = (-1) * vertices[j];
						M -= 1;
					}
					m.w = sqrt(m.x * m.x + m.y * m.y + 1);
					vertices[sorted[i]] = m;
					//vertices[sorted[i]] += 3*(m - vertices[sorted[i]]) / 4;
					//vertices[sorted[i]].w = sqrt(vertices[sorted[i]].x * vertices[sorted[i]].x + vertices[sorted[i]].y * vertices[sorted[i]].y + 1);
				}

				int idx = 0;
				for (int i = 0; i < NUM_OF_VERTICES; ++i) {
					array[idx++] = vertices[i].x / vertices[i].w;
					array[idx++] = vertices[i].y / vertices[i].w;
				}
				for (int i = 0; i < NUM_OF_CONNECTIONS; ++i) {
					array[idx++] = vertices[(const int)connections[i].x].x / vertices[(const int)connections[i].x].w;
					array[idx++] = vertices[(const int)connections[i].x].y / vertices[(const int)connections[i].x].w;
					array[idx++] = vertices[(const int)connections[i].y].x / vertices[(const int)connections[i].y].w;
					array[idx++] = vertices[(const int)connections[i].y].y / vertices[(const int)connections[i].y].w;
				}

				glBufferData(GL_ARRAY_BUFFER, 	// Copy to GPU target
					sizeof(array),  // # bytes
					array,	      	// address
					GL_DYNAMIC_DRAW);	// we do not change later

				glClearColor(0, 0, 0, 0);     // background color
				glClear(GL_COLOR_BUFFER_BIT); // clear frame buffer

				float MVPtransf[4][4] = { 1, 0, 0, 0,    // MVP matrix, 
										  0, 1, 0, 0,    // row-major!
										  0, 0, 1, 0,
										  0, 0, 0, 1 };

				glBindVertexArray(vao);  // Draw call
				int location = glGetUniformLocation(gpuProgram.getId(), "MVP");	// Get the GPU location of uniform variable MVP
				glUniformMatrix4fv(location, 1, GL_TRUE, &MVPtransf[0][0]);	// Load a 4x4 row-major float matrix to the specified location
				location = glGetUniformLocation(gpuProgram.getId(), "color");
				
				// Set color to (1, 0, 0) = red
				glUniform3f(location, 1.0f, 0.0f, 0.0f); // 3 floats
				glDrawArrays(GL_POINTS, 0 /*startIdx*/, NUM_OF_VERTICES /*# Elements*/);

				// Set color to (1, 1, 0) = yellow
				glUniform3f(location, 1.0f, 1.0f, 0.0f); // 3 floats
				glDrawArrays(GL_LINES, NUM_OF_VERTICES /*startIdx*/, NUM_OF_CONNECTIONS * 4 /*# Elements*/);

				glutSwapBuffers(); // exchange buffers for double buffering

			}
			
		}
		
	}
}

// Key of ASCII code released
void onKeyboardUp(unsigned char key, int pX, int pY) {
}

// Move mouse with key pressed
void onMouseMotion(int pX, int pY) {	// pX, pY are the pixel coordinates of the cursor in the coordinate system of the operation system
	// Convert to normalized device space
	float cX = 2.0f * pX / windowWidth - 1;	// flip y axis
	float cY = 1.0f - 2.0f * pY / windowHeight;
	printf("Mouse moved to (%3.2f, %3.2f)\n", cX, cY);
}

// Mouse click event
void onMouse(int button, int state, int pX, int pY) { // pX, pY are the pixel coordinates of the cursor in the coordinate system of the operation system
	// Convert to normalized device space
	float cX = 2.0f * pX / windowWidth - 1;	// flip y axis
	float cY = 1.0f - 2.0f * pY / windowHeight;

	char * buttonStat;
	switch (state) {
	case GLUT_DOWN: buttonStat = "pressed"; break;
	case GLUT_UP:   buttonStat = "released"; break;
	}

	switch (button) {
	case GLUT_LEFT_BUTTON:   printf("Left button %s at (%3.2f, %3.2f)\n", buttonStat, cX, cY);   break;
	case GLUT_MIDDLE_BUTTON: printf("Middle button %s at (%3.2f, %3.2f)\n", buttonStat, cX, cY); break;
	case GLUT_RIGHT_BUTTON:  printf("Right button %s at (%3.2f, %3.2f)\n", buttonStat, cX, cY);  break;
	}
}

// Idle event indicating that some time elapsed: do animation here
void onIdle() {
	long time = glutGet(GLUT_ELAPSED_TIME); // elapsed time since the start of the program
}
